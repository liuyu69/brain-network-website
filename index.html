<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brain Network (Final - Mouse Hover Effect)</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; width: 100vw; height: 100vh; overflow: hidden; }
    #brain-view { width: 100vw; height: 100vh; display: block; }
  </style>
</head>
<body>
<canvas id="brain-view"></canvas>

<!-- 
  最終解決方案：
  1. 粒子連線網路效果 (稀疏連線)。
  2. 滑鼠懸停微動效果 (非 OrbitControls)。
  3. 初始視角調整以符合用戶圖片。
  4. 修復粒子密度問題：使用與原版相同的粒子數量
-->

<script src="https://unpkg.com/three@0.125.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.0/examples/js/loaders/STLLoader.js"></script>

<script>
// --- Main Application Logic (點雲連線網路版本) ---

// 檢查 THREE 是否已定義，以確保載入成功
if (typeof THREE === 'undefined') {
    console.error("THREE.js 核心庫載入失敗！請檢查 CDN 連結。");
}

const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById('brain-view'),
    antialias: true
});

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000); // 設置背景為黑色

// 設置相機
const camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    1,
    2000
);



// *** 最終確定的初始旋轉（即回正目標）***
const initialRotationX = Math.PI / -2; // 用戶設定的 X 軸旋轉值
const initialRotationY = 0;      // 用戶設定的 Y 軸旋轉值



// 自動回正相關變數
let isMouseMoving = false;
let mouseMoveTimeout;
const autoRotateSpeed = 0.005; // 自動回正速度

// 設置滑鼠位置變數
const mouse = new THREE.Vector2();
let targetRotationX = 0;
let targetRotationY = 0;

// 處理窗口大小變化
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// 處理滑鼠移動事件 (用於微動效果)
document.addEventListener('mousemove', onDocumentMouseMove, false);

function onDocumentMouseMove(event) {
    // 將滑鼠位置標準化到 -1 到 +1 之間
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // 設置目標旋轉角度
    targetRotationY = -mouse.x * 0.7; // 左右微動 (應用到 Z 軸)
    targetRotationX = mouse.y * 0.6; // 上下微動 (應用到 Y 軸)
    
    // 設置計時器，如果滑鼠停止移動，則觸發自動回正
    isMouseMoving = true;
    clearTimeout(mouseMoveTimeout);
    mouseMoveTimeout = setTimeout(() => {
        isMouseMoving = false;
    }, 1000); // 1秒後視為停止移動
}

// 載入 STL 模型
const loader = new THREE.STLLoader();

loader.load('human-brain.stl', function(geometry) {
    
    // 載入成功，在控制台輸出訊息
    console.log('STL 模型載入成功。');

    // 檢查模型是否真的有幾何體
    const vertexCount = geometry.attributes.position ? geometry.attributes.position.count : 0;
    console.log(`STL 模型載入成功。頂點數: ${vertexCount}`);

    if (vertexCount === 0) {
        console.warn('警告：STL 檔案載入成功，但幾何體中沒有任何頂點 (可能是空檔案或格式錯誤)。');
        return;
    }

    // --- 網路連線效果邏輯 ---

    // 1. 計算邊界框並居中
    geometry.computeBoundingBox();
    const box = geometry.boundingBox;
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    
    // 2. 調整相機距離
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
    cameraZ *= 1.5; // 留出一些邊距
    
    // 3. 調整相機位置和初始視角
    camera.position.set(center.x + cameraZ * 1, center.y + cameraZ * 0, center.z + cameraZ * 0);
    camera.lookAt(center); // 讓相機看向模型中心
    camera.far = cameraZ * 1; // 與原版保持一致
    camera.updateProjectionMatrix();

    // 4. 確保模型居中
    geometry.center();

    // 5. 創建點雲 - 使用完整的STL幾何體,與原版相同
    const startSize = maxDim / 1000; // 初始粒子更小，減少雜亂感
    const endSize = maxDim / 400;
    const pointsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: startSize,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.2 // 初始透明度較低，減少視覺雜亂
    });

    const positions = geometry.attributes.position.array;
    const numVertices = positions.length / 3;
    
    // *** 關鍵修改: 使用完整的STL頂點數,而不是採樣 ***
    const morphCount = numVertices; // 使用所有頂點
    console.log('使用完整頂點數:', morphCount);

    // 目標座標: 直接使用STL的所有頂點
    const targetPositions = new Float32Array(positions); // 直接複製所有頂點

    // 起點（更緊湊的球體散佈，減少雜亂感）
    const startSpread = maxDim * 1.2; // 減小散佈範圍
    const startPositions = new Float32Array(morphCount * 3);
    for (let i = 0; i < morphCount; i++) {
        // 使用球體座標系統，讓起始點更有序
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = Math.random() * startSpread;
        startPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        startPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        startPositions[i * 3 + 2] = r * Math.cos(phi);
    }

    const morphGeometry = new THREE.BufferGeometry();
    const currentPositions = new Float32Array(startPositions);
    morphGeometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
    const points = new THREE.Points(morphGeometry, pointsMaterial);

    // 生成平滑過渡所需資料（減小控制點偏移，讓軌跡更平滑）
    const controlPositions = new Float32Array(morphCount * 3);
    const randomDelays = new Float32Array(morphCount);
    const maxDelay = 2; // 稍微增加延遲範圍，讓動畫更平滑
    for (let i = 0; i < morphCount; i++) {
        const sx = startPositions[i * 3];
        const sy = startPositions[i * 3 + 1];
        const sz = startPositions[i * 3 + 2];
        const tx = targetPositions[i * 3];
        const ty = targetPositions[i * 3 + 1];
        const tz = targetPositions[i * 3 + 2];
        // 減小控制點隨機偏移量，從 0.08 改為 0.03，讓軌跡更平滑
        const cx = (sx + tx) * 0.5 + (Math.random() * 2 - 1) * (Math.abs(tx - sx) + 1) * 0.03;
        const cy = (sy + ty) * 0.5 + (Math.random() * 2 - 1) * (Math.abs(ty - sy) + 1) * 0.03;
        const cz = (sz + tz) * 0.5 + (Math.random() * 2 - 1) * (Math.abs(tz - sz) + 1) * 0.03;
        controlPositions[i * 3] = cx;
        controlPositions[i * 3 + 1] = cy;
        controlPositions[i * 3 + 2] = cz;
        randomDelays[i] = Math.random() * maxDelay;
    }
    
    // 6. 創建稀疏連線網路 - 從完整頂點中採樣
    const lineVertices = [];
    const maxDistance = maxDim * 0.1;

    const sampledIndices = [];
    const sampleCount = Math.min(numVertices, 500); // 採樣 500 個點用於連線
    for (let i = 0; i < sampleCount; i++) {
        sampledIndices.push(Math.floor(Math.random() * numVertices));
    }

    for (let i = 0; i < sampleCount; i++) {
        const index1 = sampledIndices[i];
        const x1 = positions[index1 * 3];
        const y1 = positions[index1 * 3 + 1];
        const z1 = positions[index1 * 3 + 2];

        for (let j = i + 1; j < sampleCount; j++) {
            const index2 = sampledIndices[j];
            const x2 = positions[index2 * 3];
            const y2 = positions[index2 * 3 + 1];
            const z2 = positions[index2 * 3 + 2];

            const distance = Math.sqrt(
                Math.pow(x2 - x1, 2) +
                Math.pow(y2 - y1, 2) +
                Math.pow(z2 - z1, 2)
            );

            if (distance < maxDistance) {
                lineVertices.push(x1, y1, z1);
                lineVertices.push(x2, y2, z2);
            }
        }
    }

    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));

    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1, opacity: 0.0, transparent: true });
    const lines = new THREE.LineSegments(lineGeometry, lineMaterial);

    const group = new THREE.Group();
    group.add(points);
    group.add(lines);

    // *** 應用初始旋轉到 Group ***
    group.rotation.x = initialRotationX;
    group.rotation.y = initialRotationY;

    scene.add(group);
    
    console.log('連線網路模型已添加到場景。');

    // 粒子由隨機散佈收斂到腦模型
    let morphProgress = 0;
    let morphDone = false;
    const morphDuration = 4.0;
    function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
    const clock = new THREE.Clock();
    let morphElapsed = 0;

    // 動畫迴圈
    function animate() {
        requestAnimationFrame(animate);

        // 粒子位置與尺寸插值
        if (!morphDone) {
            const delta = clock.getDelta();
            morphElapsed += delta;
            const pos = morphGeometry.attributes.position.array;
            
            // *** 優化: 批次處理,避免每幀處理所有頂點造成性能問題 ***
            const batchSize = Math.min(5000, morphCount); // 每幀最多處理5000個頂點
            const startIdx = Math.floor((morphElapsed * 60) % (morphCount / batchSize)) * batchSize;
            const endIdx = Math.min(startIdx + batchSize, morphCount);
            
            for (let i = 0; i < morphCount; i++) {
                const localT = Math.min(1, Math.max(0, (morphElapsed - randomDelays[i]) / morphDuration));

                if (localT < 0.1) {
            // 前10%進度的粒子保持在起始位置且不可見
             pos[i * 3 + 1] = startPositions[i * 3 + 1];
             pos[i * 3 + 2] = startPositions[i * 3 + 2];
             continue;
             }
                const t = easeOutCubic(localT);
                const sx = startPositions[i * 3];
                const sy = startPositions[i * 3 + 1];
                const sz = startPositions[i * 3 + 2];
                const cx = controlPositions[i * 3];
                const cy = controlPositions[i * 3 + 1];
                const cz = controlPositions[i * 3 + 2];
                const tx = targetPositions[i * 3];
                const ty = targetPositions[i * 3 + 1];
                const tz = targetPositions[i * 3 + 2];
                const omt = 1 - t;
                const b0 = omt * omt;
                const b1 = 2 * omt * t;
                const b2 = t * t;
                pos[i * 3] = b0 * sx + b1 * cx + b2 * tx;
                pos[i * 3 + 1] = b0 * sy + b1 * cy + b2 * ty;
                pos[i * 3 + 2] = b0 * sz + b1 * cz + b2 * tz;
            }
            morphGeometry.attributes.position.needsUpdate = true;
            
            morphProgress = Math.min(1, morphElapsed / (morphDuration + maxDelay));
            const sizeT = Math.max(0, Math.min(1, morphProgress));
            pointsMaterial.size = startSize + (endSize - startSize) * sizeT;
            // 粒子透明度隨進度增加，從 0.3 漸變到 1.0
            pointsMaterial.opacity = 0.1 + (1.0 - 0.1) * sizeT;

            if (morphProgress === 1) {
                morphDone = true;
                console.log('漸變動畫完成,最終粒子數:', morphCount);
            }
        }

        // 連線網路淡入（延遲到更後期出現，減少前面階段的雜亂）
        if (!morphDone && morphProgress > 0.6) {
            const f = Math.min(0.2, (morphProgress - 0.6) / 0.4 * 0.2);
            lineMaterial.opacity = f;
        } else if (morphDone && lineMaterial.opacity < 0.2) {
            lineMaterial.opacity = 0.2;
        }

        if (isMouseMoving) {
            group.rotation.y += (targetRotationX - group.rotation.y) * 0.05;
            group.rotation.z += (targetRotationY - group.rotation.z) * 0.05;
        } else {
            const targetX = initialRotationX;
            const targetY = initialRotationY;
            const targetZ = 0;
            group.rotation.x += (targetX - group.rotation.x) * autoRotateSpeed;
            group.rotation.y += (targetY - group.rotation.y) * autoRotateSpeed;
            group.rotation.z += (targetZ - group.rotation.z) * autoRotateSpeed;
        }

        renderer.render(scene, camera);
    }

    animate();

}, (xhr) => {
    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
}, (error) => {
    console.error('STL 檔案載入時發生錯誤:', error);
});
</script>

</body>
</html>
